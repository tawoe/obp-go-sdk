/*
 * Open Bank Project API
 *
 * An Open Source API for Banks. (c) TESOBE GmbH. 2011 - 2024. Licensed under the AGPL and commercial licences.
 *
 * API version: v5.1.0
 * Contact: contact@tesobe.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package obp_golang

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type TransactionRequestApiService service

/*
TransactionRequestApiService Answer Transaction Request Challenge
&lt;p&gt;In Sandbox mode, any string that can be converted to a positive integer will be accepted as an answer.&lt;/p&gt;&lt;p&gt;This endpoint totally depends on createTransactionRequest, it need get the following data from createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;1)&lt;code&gt;TRANSACTION_REQUEST_TYPE&lt;/code&gt; : is the same as createTransactionRequest request URL .&lt;/p&gt;&lt;p&gt;2)&lt;code&gt;TRANSACTION_REQUEST_ID&lt;/code&gt; : is the &lt;code&gt;id&lt;/code&gt; field in createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;3) &lt;code&gt;id&lt;/code&gt; :  is &lt;code&gt;challenge.id&lt;/code&gt; field in createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;4) &lt;code&gt;answer&lt;/code&gt; : must be &lt;code&gt;123&lt;/code&gt; in case that Strong Customer Authentication method for OTP challenge is dummy.&lt;br /&gt;For instance: SANDBOX_TAN_OTP_INSTRUCTION_TRANSPORT&#x3D;dummy&lt;br /&gt;Possible values are dummy,email and sms&lt;br /&gt;In kafka mode, the answer can be got by phone message or other SCA methods.&lt;/p&gt;&lt;p&gt;Note that each Transaction Request Type can have its own OTP_INSTRUCTION_TRANSPORT method.&lt;br /&gt;OTP_INSTRUCTION_TRANSPORT methods are set in Props. See sample.props.template for instructions.&lt;/p&gt;&lt;p&gt;Single or Multiple authorisations&lt;/p&gt;&lt;p&gt;OBP allows single or multi party authorisations.&lt;/p&gt;&lt;p&gt;Single party authorisation:&lt;/p&gt;&lt;p&gt;In the case that only one person needs to authorise i.e. answer a security challenge we have the following change of state of a &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;Multiparty authorisation:&lt;/p&gt;&lt;p&gt;In the case that multiple parties (n persons) need to authorise a transaction request i.e. answer security challenges, we have the followings state flow for a &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in the case of a correct answer but the user is different than expected the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If Product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In the case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute, the default number of security challenges created is one.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body ChallengeAnswerJson400 object that needs to be added.
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param tRANSACTIONREQUESTTYPE The transaction request type
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *TransactionRequestApiService) AnswerTransactionRequestChallenge(ctx context.Context, body ChallengeAnswerJson400, tRANSACTIONREQUESTID string, tRANSACTIONREQUESTTYPE string, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/{TRANSACTION_REQUEST_TYPE}/transaction-requests/{TRANSACTION_REQUEST_ID}/challenge"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_TYPE"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTTYPE), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Historical Transactions
&lt;p&gt;Create historical transactions at one Bank&lt;/p&gt;&lt;p&gt;Use this endpoint to create transactions between any two accounts at the same bank.&lt;br /&gt;From account and to account must be at the same bank.&lt;br /&gt;Example:&lt;br /&gt;{&lt;br /&gt;&amp;quot;from_account_id&amp;quot;: &amp;quot;1ca8a7e4-6d02-48e3-a029-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;to_account_id&amp;quot;: &amp;quot;2ca8a7e4-6d02-48e3-a029-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;value&amp;quot;: {&lt;br /&gt;&amp;quot;currency&amp;quot;: &amp;quot;GBP&amp;quot;,&lt;br /&gt;&amp;quot;amount&amp;quot;: &amp;quot;10&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;description&amp;quot;: &amp;quot;this is for work&amp;quot;,&lt;br /&gt;&amp;quot;posted&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;completed&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;type&amp;quot;: &amp;quot;SANDBOX_TAN&amp;quot;,&lt;br /&gt;&amp;quot;charge_policy&amp;quot;: &amp;quot;SHARED&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;This call is experimental.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostHistoricalTransactionAtBankJson object that needs to be added.
  - @param bANKID The bank id

@return PostHistoricalTransactionResponseJson
*/
func (a *TransactionRequestApiService) CreateHistoricalTransactionAtBank(ctx context.Context, body PostHistoricalTransactionAtBankJson, bANKID string) (PostHistoricalTransactionResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PostHistoricalTransactionResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/management/historical/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v PostHistoricalTransactionResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorInvalidJsonFormat
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create or Update Transaction Request Attribute Definition
&lt;p&gt;Create or Update Transaction Request Attribute Definition&lt;/p&gt;&lt;p&gt;The category field must be TransactionRequest&lt;/p&gt;&lt;p&gt;The type field must be one of: DOUBLE, STRING, INTEGER and DATE_WITH_DAY&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body AttributeDefinitionJsonV400 object that needs to be added.
  - @param bANKID The bank id

@return AttributeDefinitionResponseJsonV400
*/
func (a *TransactionRequestApiService) CreateOrUpdateTransactionRequestAttributeDefinition(ctx context.Context, body AttributeDefinitionJsonV400, bANKID string) (AttributeDefinitionResponseJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AttributeDefinitionResponseJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/attribute-definitions/transaction-request"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AttributeDefinitionResponseJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (ACCOUNT)
&lt;p&gt;When using ACCOUNT, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestAccount(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/ACCOUNT/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (ACCOUNT_OTP)
&lt;p&gt;When using ACCOUNT, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestAccountOtp(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/ACCOUNT_OTP/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request Attribute
&lt;p&gt;Create Transaction Request Attribute&lt;/p&gt;&lt;p&gt;The type field must be one of &amp;quot;STRING&amp;quot;, &amp;quot;INTEGER&amp;quot;, &amp;quot;DOUBLE&amp;quot; or DATE_WITH_DAY&amp;quot;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestAttributeJsonV400 object that needs to be added.
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestAttributeResponseJson
*/
func (a *TransactionRequestApiService) CreateTransactionRequestAttribute(ctx context.Context, body TransactionRequestAttributeJsonV400, tRANSACTIONREQUESTID string, aCCOUNTID string, bANKID string) (TransactionRequestAttributeResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestAttributeResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}/attribute"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestAttributeResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (CARD)
&lt;p&gt;When using CARD, the payee is set in the request body .&lt;/p&gt;&lt;p&gt;Money goes into the Counterparty in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyCardJsonV400 object that needs to be added.

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestCard(ctx context.Context, body TransactionRequestBodyCardJsonV400) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/transaction-request-types/CARD/transaction-requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (COUNTERPARTY)
&lt;p&gt;Special instructions for COUNTERPARTY:&lt;/p&gt;&lt;p&gt;When using a COUNTERPARTY to create a Transaction Request, specificy the counterparty_id in the body of the request.&lt;br /&gt;The routing details of the counterparty will be forwarded for the transfer.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyCounterpartyJSON object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestCounterparty(ctx context.Context, body TransactionRequestBodyCounterpartyJson, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/COUNTERPARTY/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (FREE_FORM)
&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyFreeFormJSON object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestFreeForm(ctx context.Context, body TransactionRequestBodyFreeFormJson, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/FREE_FORM/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (REFUND)
&lt;p&gt;Either the &lt;code&gt;from&lt;/code&gt; or the &lt;code&gt;to&lt;/code&gt; field must be filled. Those fields refers to the information about the party that will be refunded.&lt;/p&gt;&lt;p&gt;In case the &lt;code&gt;from&lt;/code&gt; object is used, it means that the refund comes from the part that sent you a transaction.&lt;br /&gt;In the &lt;code&gt;from&lt;/code&gt; object, you have two choices :&lt;br /&gt;- Use &lt;code&gt;bank_id&lt;/code&gt; and &lt;code&gt;account_id&lt;/code&gt; fields if the other account is registered on the OBP-API&lt;br /&gt;- Use the &lt;code&gt;counterparty_id&lt;/code&gt; field in case the counterparty account is out of the OBP-API&lt;/p&gt;&lt;p&gt;In case the &lt;code&gt;to&lt;/code&gt; object is used, it means you send a request to a counterparty to ask for a refund on a previous transaction you sent.&lt;br /&gt;(This case is not managed by the OBP-API and require an external adapter)&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyRefundJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestRefund(ctx context.Context, body TransactionRequestBodyRefundJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/REFUND/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (SANDBOX_TAN)
&lt;p&gt;When using SANDBOX_TAN, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to SANDBOX_TAN. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;{&lt;br /&gt;&amp;quot;XAF&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:1.0,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.0135503,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.00228226,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1.87975,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.00127784,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.00131092,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.0396,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.00601555,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.110241,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.9074795E-8,&lt;br /&gt;&amp;quot;JPY&amp;quot;:0.185328,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.00163773,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.00641333,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.00152449&lt;br /&gt;},&lt;br /&gt;&amp;quot;HKD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:73.8049,&lt;br /&gt;&amp;quot;HKD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.178137,&lt;br /&gt;&amp;quot;KRW&amp;quot;:143.424,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0903452,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0985443,&lt;br /&gt;&amp;quot;MXN&amp;quot;:2.8067,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.467977,&lt;br /&gt;&amp;quot;INR&amp;quot;:9.09325,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.164242461E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:14.0867,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.127427,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.460862,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.112495&lt;br /&gt;},&lt;br /&gt;&amp;quot;AUD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:438.162,&lt;br /&gt;&amp;quot;HKD&amp;quot;:5.61346,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;KRW&amp;quot;:895.304,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.556152,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.609788,&lt;br /&gt;&amp;quot;MXN&amp;quot;:16.0826,&lt;br /&gt;&amp;quot;AED&amp;quot;:2.88368,&lt;br /&gt;&amp;quot;INR&amp;quot;:50.4238,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.2284055924E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:87.0936,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.785256,&lt;br /&gt;&amp;quot;ILS&amp;quot;:2.83558,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.667969&lt;br /&gt;},&lt;br /&gt;&amp;quot;KRW&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:0.531986,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.00697233,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.00111694,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1.0,&lt;br /&gt;&amp;quot;JOD&amp;quot;:6.30634E-4,&lt;br /&gt;&amp;quot;GBP&amp;quot;:6.97389E-4,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.0183,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.00320019,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.0586469,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.4234725E-8,&lt;br /&gt;&amp;quot;JPY&amp;quot;:0.0985917,&lt;br /&gt;&amp;quot;USD&amp;quot;:8.7125E-4,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.00316552,&lt;br /&gt;&amp;quot;EUR&amp;quot;:8.11008E-4&lt;br /&gt;},&lt;br /&gt;&amp;quot;JOD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:782.572,&lt;br /&gt;&amp;quot;HKD&amp;quot;:11.0687,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.63992,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1585.68,&lt;br /&gt;&amp;quot;JOD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;GBP&amp;quot;:1.06757,&lt;br /&gt;&amp;quot;MXN&amp;quot;:30.8336,&lt;br /&gt;&amp;quot;AED&amp;quot;:5.18231,&lt;br /&gt;&amp;quot;INR&amp;quot;:90.1236,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.3803244006E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:156.304,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.41112,&lt;br /&gt;&amp;quot;ILS&amp;quot;:5.02018,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.237707&lt;br /&gt;},&lt;br /&gt;&amp;quot;GBP&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:762.826,&lt;br /&gt;&amp;quot;HKD&amp;quot;:10.1468,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.63992,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1433.92,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.936707,&lt;br /&gt;&amp;quot;GBP&amp;quot;:1.0,&lt;br /&gt;&amp;quot;MXN&amp;quot;:29.242,&lt;br /&gt;&amp;quot;AED&amp;quot;:4.58882,&lt;br /&gt;&amp;quot;INR&amp;quot;:84.095,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.2756409956E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:141.373,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.2493,&lt;br /&gt;&amp;quot;ILS&amp;quot;:4.7002,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.16278&lt;br /&gt;},&lt;br /&gt;&amp;quot;MXN&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:25.189,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.3562,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0621,&lt;br /&gt;&amp;quot;KRW&amp;quot;:54.4512,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0324,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0341,&lt;br /&gt;&amp;quot;MXN&amp;quot;:1.0,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.1688,&lt;br /&gt;&amp;quot;INR&amp;quot;:3.3513,&lt;br /&gt;&amp;quot;XBT&amp;quot;:8.1112586E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:4.8687,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.0459,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.1541,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.0384&lt;br /&gt;},&lt;br /&gt;&amp;quot;AED&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:166.236,&lt;br /&gt;&amp;quot;HKD&amp;quot;:2.13685,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.346779,&lt;br /&gt;&amp;quot;KRW&amp;quot;:312.482,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.1930565,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.217921,&lt;br /&gt;&amp;quot;MXN&amp;quot;:5.9217,&lt;br /&gt;&amp;quot;AED&amp;quot;:1.0,&lt;br /&gt;&amp;quot;INR&amp;quot;:18.3255,&lt;br /&gt;&amp;quot;XBT&amp;quot;:4.603349217E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:30.8081,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.27225,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.968033,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.253425&lt;br /&gt;},&lt;br /&gt;&amp;quot;INR&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:9.07101,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.109972,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0198319,&lt;br /&gt;&amp;quot;KRW&amp;quot;:17.0512,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0110959,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0118913,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.2983,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.0545671,&lt;br /&gt;&amp;quot;INR&amp;quot;:1.0,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.2689396E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:1.68111,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.0148559,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.0556764,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.0138287&lt;br /&gt;},&lt;br /&gt;&amp;quot;XBT&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:3.4353824E7,&lt;br /&gt;&amp;quot;HKD&amp;quot;:460448.9,&lt;br /&gt;&amp;quot;AUD&amp;quot;:81168.603,&lt;br /&gt;&amp;quot;KRW&amp;quot;:7.0131575E7,&lt;br /&gt;&amp;quot;JOD&amp;quot;:41960.111,&lt;br /&gt;&amp;quot;GBP&amp;quot;:44188.118,&lt;br /&gt;&amp;quot;MXN&amp;quot;:1230503.3,&lt;br /&gt;&amp;quot;AED&amp;quot;:217414.47,&lt;br /&gt;&amp;quot;INR&amp;quot;:4407607.74,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.0,&lt;br /&gt;&amp;quot;JPY&amp;quot;:6805170.8,&lt;br /&gt;&amp;quot;USD&amp;quot;:59245.918,&lt;br /&gt;&amp;quot;ILS&amp;quot;:182981.21,&lt;br /&gt;&amp;quot;EUR&amp;quot;:52436.431&lt;br /&gt;},&lt;br /&gt;&amp;quot;JPY&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:5.39585,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.0709891,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0114819,&lt;br /&gt;&amp;quot;KRW&amp;quot;:10.1428,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.00639777,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0070735,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.2053,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.032459,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.594846,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.47171931E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:1.0,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.00883695,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.0320926,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.00822592&lt;br /&gt;},&lt;br /&gt;&amp;quot;USD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:610.601,&lt;br /&gt;&amp;quot;HKD&amp;quot;:7.84766,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.27347,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1147.78,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.708659,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.800446,&lt;br /&gt;&amp;quot;MXN&amp;quot;:21.748,&lt;br /&gt;&amp;quot;AED&amp;quot;:3.6731,&lt;br /&gt;&amp;quot;INR&amp;quot;:67.3135,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.69154E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:113.161,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;ILS&amp;quot;:3.55495,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.930886&lt;br /&gt;},&lt;br /&gt;&amp;quot;ILS&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:155.925,&lt;br /&gt;&amp;quot;HKD&amp;quot;:2.16985,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.352661,&lt;br /&gt;&amp;quot;KRW&amp;quot;:315.903,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.199196,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.212763,&lt;br /&gt;&amp;quot;MXN&amp;quot;:6.4871,&lt;br /&gt;&amp;quot;AED&amp;quot;:1.03302,&lt;br /&gt;&amp;quot;INR&amp;quot;:17.9609,&lt;br /&gt;&amp;quot;XBT&amp;quot;:5.452272147E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:31.1599,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.281298,&lt;br /&gt;&amp;quot;ILS&amp;quot;:1.0,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.19318&lt;br /&gt;},&lt;br /&gt;&amp;quot;EUR&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:655.957,&lt;br /&gt;&amp;quot;HKD&amp;quot;:8.88926,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.49707,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1233.03,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.838098,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.860011,&lt;br /&gt;&amp;quot;MXN&amp;quot;:26.0359,&lt;br /&gt;&amp;quot;AED&amp;quot;:3.94594,&lt;br /&gt;&amp;quot;INR&amp;quot;:72.3136,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.9087905636E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:121.567,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.07428,&lt;br /&gt;&amp;quot;ILS&amp;quot;:4.20494,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.0&lt;br /&gt;}&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *TransactionRequestApiService) CreateTransactionRequestSandboxTan(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SANDBOX_TAN/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (SEPA)
&lt;p&gt;Special instructions for SEPA:&lt;/p&gt;&lt;p&gt;When using a SEPA Transaction Request, you specify the IBAN of a Counterparty in the body of the request.&lt;br /&gt;The routing details (IBAN) of the counterparty will be forwarded to the core banking system for the transfer.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodySEPAJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestSepa(ctx context.Context, body TransactionRequestBodySepaJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SEPA/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Create Transaction Request (SIMPLE)
&lt;p&gt;Special instructions for SIMPLE:&lt;/p&gt;&lt;p&gt;You can transfer money to the Bank Account Number or IBAN directly.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodySimpleJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *TransactionRequestApiService) CreateTransactionRequestSimple(ctx context.Context, body TransactionRequestBodySimpleJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SIMPLE/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Delete Transaction Request Attribute Definition
&lt;p&gt;Delete Transaction Request Attribute Definition by ATTRIBUTE_DEFINITION_ID&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return Full
*/
func (a *TransactionRequestApiService) DeleteTransactionRequestAttributeDefinition(ctx context.Context, bANKID string) (Full, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Full
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/attribute-definitions/ATTRIBUTE_DEFINITION_ID/transaction-request"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 204 {
			var v Full
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request.
&lt;p&gt;Returns transaction request for transaction specified by TRANSACTION_REQUEST_ID and for account specified by ACCOUNT_ID at bank specified by BANK_ID.&lt;/p&gt;&lt;p&gt;The VIEW_ID specified must be &#39;owner&#39; and the user must have access to this view.&lt;/p&gt;&lt;p&gt;Version 2.0.0 now returns charge information.&lt;/p&gt;&lt;p&gt;Transaction Requests serve to initiate transactions that may or may not proceed. They contain information including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Transaction Request Id&lt;/li&gt;&lt;li&gt;Type&lt;/li&gt;&lt;li&gt;Status (INITIATED, COMPLETED)&lt;/li&gt;&lt;li&gt;Challenge (in order to confirm the request)&lt;/li&gt;&lt;li&gt;From Bank / Account&lt;/li&gt;&lt;li&gt;Details including Currency, Value, Description and other initiation information specific to each type. (Could potentialy include a list of future transactions.)&lt;/li&gt;&lt;li&gt;Related Transactions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;PSD2 Context: PSD2 requires transparency of charges to the customer.&lt;br /&gt;This endpoint provides the charge that would be applied if the Transaction Request proceeds - and a record of that charge there after.&lt;br /&gt;The customer can proceed with the Transaction by answering the security challenge.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *TransactionRequestApiService) GetTransactionRequest(ctx context.Context, tRANSACTIONREQUESTID string, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request Attribute By Id
&lt;p&gt;Get Transaction Request Attribute By Id&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestAttributeResponseJson
*/
func (a *TransactionRequestApiService) GetTransactionRequestAttributeById(ctx context.Context, tRANSACTIONREQUESTID string, aCCOUNTID string, bANKID string) (TransactionRequestAttributeResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestAttributeResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}/attributes/ATTRIBUTE_ID"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestAttributeResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request Attribute Definition
&lt;p&gt;Get Transaction Request Attribute Definition&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return AttributeDefinitionsResponseJsonV400
*/
func (a *TransactionRequestApiService) GetTransactionRequestAttributeDefinition(ctx context.Context, bANKID string) (AttributeDefinitionsResponseJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AttributeDefinitionsResponseJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/attribute-definitions/transaction-request"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AttributeDefinitionsResponseJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request Attributes
&lt;p&gt;Get Transaction Request Attributes&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestAttributesResponseJson
*/
func (a *TransactionRequestApiService) GetTransactionRequestAttributes(ctx context.Context, tRANSACTIONREQUESTID string, aCCOUNTID string, bANKID string) (TransactionRequestAttributesResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestAttributesResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestAttributesResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request Types for Account
&lt;p&gt;Returns the Transaction Request Types that the account specified by ACCOUNT_ID and view specified by VIEW_ID has access to.&lt;/p&gt;&lt;p&gt;These are the ways this API Server can create a Transaction via a Transaction Request&lt;br /&gt;(as opposed to Transaction Types which include external types too e.g. for Transactions created by core banking etc.)&lt;/p&gt;&lt;p&gt;A Transaction Request Type internally determines:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the required Transaction Request &#39;body&#39; i.e. fields that define the &#39;what&#39; and &#39;to&#39; of a Transaction Request,&lt;/li&gt;&lt;li&gt;the type of security challenge that may be be raised before the Transaction Request proceeds, and&lt;/li&gt;&lt;li&gt;the threshold of that challenge.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For instance in a &#39;SANDBOX_TAN&#39; Transaction Request, for amounts over 1000 currency units, the user must supply a positive integer to complete the Transaction Request and create a Transaction.&lt;/p&gt;&lt;p&gt;This approach aims to provide only one endpoint for initiating transactions, and one that handles challenges, whilst still allowing flexibility with the payload and internal logic.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body EmptyClassJson object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestTypesJsonV140
*/
func (a *TransactionRequestApiService) GetTransactionRequestTypes(ctx context.Context, body EmptyClassJson, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestTypesJsonV140, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestTypesJsonV140
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestTypesJsonV140
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Request Types at Bank
&lt;p&gt;Get the list of the Transaction Request Types supported by the bank.&lt;/p&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body EmptyClassJson object that needs to be added.
  - @param bANKID The bank id

@return TransactionRequestTypesJson
*/
func (a *TransactionRequestApiService) GetTransactionRequestTypesSupportedByBank(ctx context.Context, body EmptyClassJson, bANKID string) (TransactionRequestTypesJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestTypesJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/transaction-request-types"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestTypesJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUnknownError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Get Transaction Requests.
&lt;p&gt;Returns transaction requests for account specified by ACCOUNT_ID at bank specified by BANK_ID.&lt;/p&gt;&lt;p&gt;The VIEW_ID specified must be &#39;owner&#39; and the user must have access to this view.&lt;/p&gt;&lt;p&gt;Version 2.0.0 now returns charge information.&lt;/p&gt;&lt;p&gt;Transaction Requests serve to initiate transactions that may or may not proceed. They contain information including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Transaction Request Id&lt;/li&gt;&lt;li&gt;Type&lt;/li&gt;&lt;li&gt;Status (INITIATED, COMPLETED)&lt;/li&gt;&lt;li&gt;Challenge (in order to confirm the request)&lt;/li&gt;&lt;li&gt;From Bank / Account&lt;/li&gt;&lt;li&gt;Details including Currency, Value, Description and other initiation information specific to each type. (Could potentialy include a list of future transactions.)&lt;/li&gt;&lt;li&gt;Related Transactions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;PSD2 Context: PSD2 requires transparency of charges to the customer.&lt;br /&gt;This endpoint provides the charge that would be applied if the Transaction Request proceeds - and a record of that charge there after.&lt;br /&gt;The customer can proceed with the Transaction by answering the security challenge.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJsons210
*/
func (a *TransactionRequestApiService) GetTransactionRequests(ctx context.Context, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJsons210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJsons210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestWithChargeJsons210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Save Historical Transactions
&lt;p&gt;Import the historical transactions.&lt;/p&gt;&lt;p&gt;The fields bank_id, account_id, counterparty_id in the json body are all optional ones.&lt;br /&gt;It support transfer money from account to account, account to counterparty and counterparty to counterparty&lt;br /&gt;Both bank_id + account_id and counterparty_id can identify the account, so OBP only need one of them to make the payment.&lt;br /&gt;So:&lt;br /&gt;When you need the account to account, just omit counterparty_id field.eg:&lt;br /&gt;{&lt;br /&gt;&amp;quot;from&amp;quot;: {&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;gh.29.uk&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;1ca8a7e4-6d02-48e3-a029-0b2bf89de9f0&amp;quot;,&lt;br /&gt;},&lt;br /&gt;&amp;quot;to&amp;quot;: {&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;gh.29.uk&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;2ca8a7e4-6d02-48e3-a029-0b2bf89de9f0&amp;quot;,&lt;br /&gt;},&lt;br /&gt;&amp;quot;value&amp;quot;: {&lt;br /&gt;&amp;quot;currency&amp;quot;: &amp;quot;GBP&amp;quot;,&lt;br /&gt;&amp;quot;amount&amp;quot;: &amp;quot;10&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;description&amp;quot;: &amp;quot;this is for work&amp;quot;,&lt;br /&gt;&amp;quot;posted&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;completed&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;type&amp;quot;: &amp;quot;SANDBOX_TAN&amp;quot;,&lt;br /&gt;&amp;quot;charge_policy&amp;quot;: &amp;quot;SHARED&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;When you need the counterparty to counterparty, need to omit bank_id and account_id field.eg:&lt;br /&gt;{&lt;br /&gt;&amp;quot;from&amp;quot;: {&lt;br /&gt;&amp;quot;counterparty_id&amp;quot;: &amp;quot;f6392b7d-4218-45ea-b9a7-eaa71c0202f9&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;to&amp;quot;: {&lt;br /&gt;&amp;quot;counterparty_id&amp;quot;: &amp;quot;26392b7d-4218-45ea-b9a7-eaa71c0202f9&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;value&amp;quot;: {&lt;br /&gt;&amp;quot;currency&amp;quot;: &amp;quot;GBP&amp;quot;,&lt;br /&gt;&amp;quot;amount&amp;quot;: &amp;quot;10&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;description&amp;quot;: &amp;quot;this is for work&amp;quot;,&lt;br /&gt;&amp;quot;posted&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;completed&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;type&amp;quot;: &amp;quot;SANDBOX_TAN&amp;quot;,&lt;br /&gt;&amp;quot;charge_policy&amp;quot;: &amp;quot;SHARED&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;or, you can counterparty to account&lt;br /&gt;{&lt;br /&gt;&amp;quot;from&amp;quot;: {&lt;br /&gt;&amp;quot;counterparty_id&amp;quot;: &amp;quot;f6392b7d-4218-45ea-b9a7-eaa71c0202f9&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;to&amp;quot;: {&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;gh.29.uk&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-48e3-a029-0b2bf89de9f0&amp;quot;,&lt;br /&gt;},&lt;br /&gt;&amp;quot;value&amp;quot;: {&lt;br /&gt;&amp;quot;currency&amp;quot;: &amp;quot;GBP&amp;quot;,&lt;br /&gt;&amp;quot;amount&amp;quot;: &amp;quot;10&amp;quot;&lt;br /&gt;},&lt;br /&gt;&amp;quot;description&amp;quot;: &amp;quot;this is for work&amp;quot;,&lt;br /&gt;&amp;quot;posted&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;completed&amp;quot;: &amp;quot;2017-09-19T02:31:05Z&amp;quot;,&lt;br /&gt;&amp;quot;type&amp;quot;: &amp;quot;SANDBOX_TAN&amp;quot;,&lt;br /&gt;&amp;quot;charge_policy&amp;quot;: &amp;quot;SHARED&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;This call is experimental.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostHistoricalTransactionJson object that needs to be added.

@return PostHistoricalTransactionResponseJson
*/
func (a *TransactionRequestApiService) SaveHistoricalTransaction(ctx context.Context, body PostHistoricalTransactionJson) (PostHistoricalTransactionResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PostHistoricalTransactionResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/management/historical/transactions "

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v PostHistoricalTransactionResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorInvalidJsonFormat
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TransactionRequestApiService Update Transaction Request Attribute
&lt;p&gt;Update Transaction Request Attribute&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestAttributeJsonV400 object that needs to be added.
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestAttributeResponseJson
*/
func (a *TransactionRequestApiService) UpdateTransactionRequestAttribute(ctx context.Context, body TransactionRequestAttributeJsonV400, tRANSACTIONREQUESTID string, aCCOUNTID string, bANKID string) (TransactionRequestAttributeResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestAttributeResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}/attributes/ATTRIBUTE_ID"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestAttributeResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
