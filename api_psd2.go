/*
 * Open Bank Project API
 *
 * An Open Source API for Banks. (c) TESOBE GmbH. 2011 - 2024. Licensed under the AGPL and commercial licences.
 *
 * API version: v5.1.0
 * Contact: contact@tesobe.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package obp_golang

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type PSD2ApiService service

/*
PSD2ApiService Answer Consent Challenge
&lt;p&gt;An OBP Consent allows the holder of the Consent to call one or more endpoints.&lt;/p&gt;&lt;p&gt;Consents must be created and authorisied using SCA (Strong Customer Authentication).&lt;/p&gt;&lt;p&gt;That is, Consents can be created by an authorised User via the OBP REST API but they must be confirmed via an out of band (OOB) mechanism such as a code sent to a mobile phone.&lt;/p&gt;&lt;p&gt;Each Consent has one of the following states: INITIATED, ACCEPTED, REJECTED, REVOKED, RECEIVED, VALID, REVOKEDBYPSU, EXPIRED, TERMINATEDBYTPP, AUTHORISED, AWAITINGAUTHORISATION.&lt;/p&gt;&lt;p&gt;Each Consent is bound to a consumer i.e. you need to identify yourself over request header value Consumer-Key.&lt;br /&gt;For example:&lt;br /&gt;GET /obp/v4.0.0/users/current HTTP/1.1&lt;br /&gt;Host: 127.0.0.1:8080&lt;br /&gt;Consent-JWT: eyJhbGciOiJIUzI1NiJ9.eyJlbnRpdGxlbWVudHMiOlt7InJvbGVfbmFtZSI6IkNhbkdldEFueVVzZXIiLCJiYW5rX2lkIjoiIn&lt;br /&gt;1dLCJjcmVhdGVkQnlVc2VySWQiOiJhYjY1MzlhOS1iMTA1LTQ0ODktYTg4My0wYWQ4ZDZjNjE2NTciLCJzdWIiOiIzNDc1MDEzZi03YmY5LTQyNj&lt;br /&gt;EtOWUxYy0xZTdlNWZjZTJlN2UiLCJhdWQiOiI4MTVhMGVmMS00YjZhLTQyMDUtYjExMi1lNDVmZDZmNGQzYWQiLCJuYmYiOjE1ODA3NDE2NjcsIml&lt;br /&gt;zcyI6Imh0dHA6XC9cLzEyNy4wLjAuMTo4MDgwIiwiZXhwIjoxNTgwNzQ1MjY3LCJpYXQiOjE1ODA3NDE2NjcsImp0aSI6ImJkYzVjZTk5LTE2ZTY&lt;br /&gt;tNDM4Yi1hNjllLTU3MTAzN2RhMTg3OCIsInZpZXdzIjpbXX0.L3fEEEhdCVr3qnmyRKBBUaIQ7dk1VjiFaEBW8hUNjfg&lt;/p&gt;&lt;p&gt;Consumer-Key: ejznk505d132ryomnhbx1qmtohurbsbb0kijajsk&lt;br /&gt;cache-control: no-cache&lt;/p&gt;&lt;p&gt;Maximum time to live of the token is specified over props value consents.max_time_to_live. In case isn&#39;t defined default value is 3600 seconds.&lt;/p&gt;&lt;p&gt;Example of POST JSON:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#109;a&amp;#105;&amp;#x6c;&amp;#x74;&amp;#x6f;&amp;#x3a;&amp;#101;&amp;#x76;&amp;#x65;l&amp;#105;&amp;#x6e;&amp;#101;@&amp;#101;&amp;#120;&amp;#97;m&amp;#112;l&amp;#x65;&amp;#46;&amp;#x63;&amp;#x6f;&amp;#109;\&quot;&gt;&amp;#101;v&amp;#x65;&amp;#x6c;i&amp;#110;&amp;#x65;&amp;#x40;&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#x6c;&amp;#x65;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;&amp;quot;,&lt;br /&gt;&amp;quot;valid_from&amp;quot;: &amp;quot;2020-02-07T08:43:34Z&amp;quot;,&lt;br /&gt;&amp;quot;time_to_live&amp;quot;: 3600&lt;br /&gt;}&lt;br /&gt;Please note that only optional fields are: consumer_id, valid_from and time_to_live.&lt;br /&gt;In case you omit they the default values are used:&lt;br /&gt;consumer_id &#x3D; consumer of current user&lt;br /&gt;valid_from &#x3D; current time&lt;br /&gt;time_to_live &#x3D; consents.max_time_to_live&lt;/p&gt;&lt;p&gt;This endpoint is used to confirm a Consent previously created.&lt;/p&gt;&lt;p&gt;The User must supply a code that was sent out of band (OOB) for example via an SMS.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostConsentChallengeJsonV310 object that needs to be added.
  - @param cONSENTID the consent id
  - @param bANKID The bank id

@return ConsentChallengeJsonV310
*/
func (a *PSD2ApiService) AnswerConsentChallenge(ctx context.Context, body PostConsentChallengeJsonV310, cONSENTID string, bANKID string) (ConsentChallengeJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentChallengeJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/consents/{CONSENT_ID}/challenge"
	localVarPath = strings.Replace(localVarPath, "{"+"CONSENT_ID"+"}", fmt.Sprintf("%v", cONSENTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentChallengeJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Answer Transaction Request Challenge
&lt;p&gt;In Sandbox mode, any string that can be converted to a positive integer will be accepted as an answer.&lt;/p&gt;&lt;p&gt;This endpoint totally depends on createTransactionRequest, it need get the following data from createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;1)&lt;code&gt;TRANSACTION_REQUEST_TYPE&lt;/code&gt; : is the same as createTransactionRequest request URL .&lt;/p&gt;&lt;p&gt;2)&lt;code&gt;TRANSACTION_REQUEST_ID&lt;/code&gt; : is the &lt;code&gt;id&lt;/code&gt; field in createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;3) &lt;code&gt;id&lt;/code&gt; :  is &lt;code&gt;challenge.id&lt;/code&gt; field in createTransactionRequest response body.&lt;/p&gt;&lt;p&gt;4) &lt;code&gt;answer&lt;/code&gt; : must be &lt;code&gt;123&lt;/code&gt; in case that Strong Customer Authentication method for OTP challenge is dummy.&lt;br /&gt;For instance: SANDBOX_TAN_OTP_INSTRUCTION_TRANSPORT&#x3D;dummy&lt;br /&gt;Possible values are dummy,email and sms&lt;br /&gt;In kafka mode, the answer can be got by phone message or other SCA methods.&lt;/p&gt;&lt;p&gt;Note that each Transaction Request Type can have its own OTP_INSTRUCTION_TRANSPORT method.&lt;br /&gt;OTP_INSTRUCTION_TRANSPORT methods are set in Props. See sample.props.template for instructions.&lt;/p&gt;&lt;p&gt;Single or Multiple authorisations&lt;/p&gt;&lt;p&gt;OBP allows single or multi party authorisations.&lt;/p&gt;&lt;p&gt;Single party authorisation:&lt;/p&gt;&lt;p&gt;In the case that only one person needs to authorise i.e. answer a security challenge we have the following change of state of a &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;Multiparty authorisation:&lt;/p&gt;&lt;p&gt;In the case that multiple parties (n persons) need to authorise a transaction request i.e. answer security challenges, we have the followings state flow for a &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in the case of a correct answer but the user is different than expected the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If Product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In the case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute, the default number of security challenges created is one.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body ChallengeAnswerJson400 object that needs to be added.
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param tRANSACTIONREQUESTTYPE The transaction request type
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *PSD2ApiService) AnswerTransactionRequestChallenge(ctx context.Context, body ChallengeAnswerJson400, tRANSACTIONREQUESTID string, tRANSACTIONREQUESTTYPE string, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/{TRANSACTION_REQUEST_TYPE}/transaction-requests/{TRANSACTION_REQUEST_ID}/challenge"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_TYPE"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTTYPE), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Check Available Funds
&lt;p&gt;Check Available Funds&lt;br /&gt;Mandatory URL parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;amount&#x3D;NUMBER&lt;/li&gt;&lt;li&gt;currency&#x3D;STRING&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return CheckFundsAvailableJson
*/
func (a *PSD2ApiService) CheckFundsAvailable(ctx context.Context, vIEWID string, aCCOUNTID string, bANKID string) (CheckFundsAvailableJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CheckFundsAvailableJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/funds-available"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CheckFundsAvailableJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Accounts at all Banks (private)
&lt;p&gt;Returns the list of accounts containing private views for the user.&lt;br /&gt;Each account lists the views available to the user.&lt;/p&gt;&lt;p&gt;optional request parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;account_type_filter: one or many accountType value, split by comma&lt;/li&gt;&lt;li&gt;account_type_filter_operation: the filter type of account_type_filter, value must be INCLUDE or EXCLUDE&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;whole url example:&lt;br /&gt;/my/accounts?account_type_filter&#x3D;330,CURRENT+PLUS&amp;amp;account_type_filter_operation&#x3D;INCLUDE&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return CoreAccountsJsonV300
*/
func (a *PSD2ApiService) CorePrivateAccountsAllBanks(ctx context.Context) (CoreAccountsJsonV300, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CoreAccountsJsonV300
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/my/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CoreAccountsJsonV300
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent By CONSENT_REQUEST_ID (EMAIL)
&lt;p&gt;This endpoint continues the process of creating a Consent. It starts the SCA flow which changes the status of the consent from INITIATED to ACCEPTED or REJECTED.&lt;br /&gt;Please note that the Consent cannot elevate the privileges logged in user already have.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentJsonV500
*/
func (a *PSD2ApiService) CreateConsentByConsentRequestIdEmail(ctx context.Context) (ConsentJsonV500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests/CONSENT_REQUEST_ID/EMAIL/consents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent By CONSENT_REQUEST_ID (IMPLICIT)
&lt;p&gt;This endpoint continues the process of creating a Consent. It starts the SCA flow which changes the status of the consent from INITIATED to ACCEPTED or REJECTED.&lt;br /&gt;Please note that the Consent cannot elevate the privileges logged in user already have.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentJsonV500
*/
func (a *PSD2ApiService) CreateConsentByConsentRequestIdImplicit(ctx context.Context) (ConsentJsonV500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests/CONSENT_REQUEST_ID/IMPLICIT/consents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent By CONSENT_REQUEST_ID (SMS)
&lt;p&gt;This endpoint continues the process of creating a Consent. It starts the SCA flow which changes the status of the consent from INITIATED to ACCEPTED or REJECTED.&lt;br /&gt;Please note that the Consent cannot elevate the privileges logged in user already have.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentJsonV500
*/
func (a *PSD2ApiService) CreateConsentByConsentRequestIdSms(ctx context.Context) (ConsentJsonV500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests/CONSENT_REQUEST_ID/SMS/consents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent (EMAIL)
&lt;p&gt;This endpoint starts the process of creating a Consent.&lt;/p&gt;&lt;p&gt;The Consent is created in an INITIATED state.&lt;/p&gt;&lt;p&gt;A One Time Password (OTP) (AKA security challenge) is sent Out of Band (OOB) to the User via the transport defined in SCA_METHOD&lt;br /&gt;SCA_METHOD is typically &amp;quot;SMS&amp;quot;,&amp;quot;EMAIL&amp;quot; or &amp;quot;IMPLICIT&amp;quot;. &amp;quot;EMAIL&amp;quot; is used for testing purposes. OBP mapped mode &amp;quot;IMPLICIT&amp;quot; is &amp;quot;EMAIL&amp;quot;.&lt;br /&gt;Other mode, bank can decide it in the connector method &#39;getConsentImplicitSCA&#39;.&lt;/p&gt;&lt;p&gt;When the Consent is created, OBP (or a backend system) stores the challenge so it can be checked later against the value supplied by the User with the Answer Consent Challenge endpoint.&lt;/p&gt;&lt;p&gt;An OBP Consent allows the holder of the Consent to call one or more endpoints.&lt;/p&gt;&lt;p&gt;Consents must be created and authorisied using SCA (Strong Customer Authentication).&lt;/p&gt;&lt;p&gt;That is, Consents can be created by an authorised User via the OBP REST API but they must be confirmed via an out of band (OOB) mechanism such as a code sent to a mobile phone.&lt;/p&gt;&lt;p&gt;Each Consent has one of the following states: INITIATED, ACCEPTED, REJECTED, REVOKED, RECEIVED, VALID, REVOKEDBYPSU, EXPIRED, TERMINATEDBYTPP, AUTHORISED, AWAITINGAUTHORISATION.&lt;/p&gt;&lt;p&gt;Each Consent is bound to a consumer i.e. you need to identify yourself over request header value Consumer-Key.&lt;br /&gt;For example:&lt;br /&gt;GET /obp/v4.0.0/users/current HTTP/1.1&lt;br /&gt;Host: 127.0.0.1:8080&lt;br /&gt;Consent-JWT: eyJhbGciOiJIUzI1NiJ9.eyJlbnRpdGxlbWVudHMiOlt7InJvbGVfbmFtZSI6IkNhbkdldEFueVVzZXIiLCJiYW5rX2lkIjoiIn&lt;br /&gt;1dLCJjcmVhdGVkQnlVc2VySWQiOiJhYjY1MzlhOS1iMTA1LTQ0ODktYTg4My0wYWQ4ZDZjNjE2NTciLCJzdWIiOiIzNDc1MDEzZi03YmY5LTQyNj&lt;br /&gt;EtOWUxYy0xZTdlNWZjZTJlN2UiLCJhdWQiOiI4MTVhMGVmMS00YjZhLTQyMDUtYjExMi1lNDVmZDZmNGQzYWQiLCJuYmYiOjE1ODA3NDE2NjcsIml&lt;br /&gt;zcyI6Imh0dHA6XC9cLzEyNy4wLjAuMTo4MDgwIiwiZXhwIjoxNTgwNzQ1MjY3LCJpYXQiOjE1ODA3NDE2NjcsImp0aSI6ImJkYzVjZTk5LTE2ZTY&lt;br /&gt;tNDM4Yi1hNjllLTU3MTAzN2RhMTg3OCIsInZpZXdzIjpbXX0.L3fEEEhdCVr3qnmyRKBBUaIQ7dk1VjiFaEBW8hUNjfg&lt;/p&gt;&lt;p&gt;Consumer-Key: ejznk505d132ryomnhbx1qmtohurbsbb0kijajsk&lt;br /&gt;cache-control: no-cache&lt;/p&gt;&lt;p&gt;Maximum time to live of the token is specified over props value consents.max_time_to_live. In case isn&#39;t defined default value is 3600 seconds.&lt;/p&gt;&lt;p&gt;Example of POST JSON:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#x6d;&amp;#97;&amp;#105;&amp;#108;&amp;#x74;&amp;#111;&amp;#58;&amp;#x65;&amp;#118;&amp;#x65;&amp;#x6c;&amp;#x69;&amp;#x6e;&amp;#101;&amp;#x40;&amp;#101;&amp;#120;a&amp;#109;&amp;#x70;&amp;#x6c;e&amp;#x2e;&amp;#99;&amp;#111;&amp;#109;\&quot;&gt;&amp;#x65;&amp;#118;e&amp;#x6c;&amp;#105;&amp;#110;&amp;#x65;&amp;#64;&amp;#x65;&amp;#120;&amp;#97;&amp;#109;&amp;#x70;&amp;#x6c;&amp;#x65;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;&lt;/a&gt;&amp;quot;,&lt;br /&gt;&amp;quot;valid_from&amp;quot;: &amp;quot;2020-02-07T08:43:34Z&amp;quot;,&lt;br /&gt;&amp;quot;time_to_live&amp;quot;: 3600&lt;br /&gt;}&lt;br /&gt;Please note that only optional fields are: consumer_id, valid_from and time_to_live.&lt;br /&gt;In case you omit they the default values are used:&lt;br /&gt;consumer_id &#x3D; consumer of current user&lt;br /&gt;valid_from &#x3D; current time&lt;br /&gt;time_to_live &#x3D; consents.max_time_to_live&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;&lt;p&gt;Example 1:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;phone_number&amp;quot;: &amp;quot;+49 170 1234567&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note that consumer_id is optional field&lt;br /&gt;Example 2:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;&amp;quot;phone_number&amp;quot;: &amp;quot;+49 170 1234567&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note if everything&#x3D;false you need to explicitly specify views and entitlements&lt;br /&gt;Example 3:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;phone_number&amp;quot;: &amp;quot;+49 170 1234567&amp;quot;&lt;br /&gt;}&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostConsentEmailJsonV310 object that needs to be added.
  - @param bANKID The bank id

@return ConsentJsonV310
*/
func (a *PSD2ApiService) CreateConsentEmail(ctx context.Context, body PostConsentEmailJsonV310, bANKID string) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consents/EMAIL"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent (IMPLICIT)
&lt;p&gt;This endpoint starts the process of creating a Consent.&lt;/p&gt;&lt;p&gt;The Consent is created in an INITIATED state.&lt;/p&gt;&lt;p&gt;A One Time Password (OTP) (AKA security challenge) is sent Out of Band (OOB) to the User via the transport defined in SCA_METHOD&lt;br /&gt;SCA_METHOD is typically &amp;quot;SMS&amp;quot;,&amp;quot;EMAIL&amp;quot; or &amp;quot;IMPLICIT&amp;quot;. &amp;quot;EMAIL&amp;quot; is used for testing purposes. OBP mapped mode &amp;quot;IMPLICIT&amp;quot; is &amp;quot;EMAIL&amp;quot;.&lt;br /&gt;Other mode, bank can decide it in the connector method &#39;getConsentImplicitSCA&#39;.&lt;/p&gt;&lt;p&gt;When the Consent is created, OBP (or a backend system) stores the challenge so it can be checked later against the value supplied by the User with the Answer Consent Challenge endpoint.&lt;/p&gt;&lt;p&gt;An OBP Consent allows the holder of the Consent to call one or more endpoints.&lt;/p&gt;&lt;p&gt;Consents must be created and authorisied using SCA (Strong Customer Authentication).&lt;/p&gt;&lt;p&gt;That is, Consents can be created by an authorised User via the OBP REST API but they must be confirmed via an out of band (OOB) mechanism such as a code sent to a mobile phone.&lt;/p&gt;&lt;p&gt;Each Consent has one of the following states: INITIATED, ACCEPTED, REJECTED, REVOKED, RECEIVED, VALID, REVOKEDBYPSU, EXPIRED, TERMINATEDBYTPP, AUTHORISED, AWAITINGAUTHORISATION.&lt;/p&gt;&lt;p&gt;Each Consent is bound to a consumer i.e. you need to identify yourself over request header value Consumer-Key.&lt;br /&gt;For example:&lt;br /&gt;GET /obp/v4.0.0/users/current HTTP/1.1&lt;br /&gt;Host: 127.0.0.1:8080&lt;br /&gt;Consent-JWT: eyJhbGciOiJIUzI1NiJ9.eyJlbnRpdGxlbWVudHMiOlt7InJvbGVfbmFtZSI6IkNhbkdldEFueVVzZXIiLCJiYW5rX2lkIjoiIn&lt;br /&gt;1dLCJjcmVhdGVkQnlVc2VySWQiOiJhYjY1MzlhOS1iMTA1LTQ0ODktYTg4My0wYWQ4ZDZjNjE2NTciLCJzdWIiOiIzNDc1MDEzZi03YmY5LTQyNj&lt;br /&gt;EtOWUxYy0xZTdlNWZjZTJlN2UiLCJhdWQiOiI4MTVhMGVmMS00YjZhLTQyMDUtYjExMi1lNDVmZDZmNGQzYWQiLCJuYmYiOjE1ODA3NDE2NjcsIml&lt;br /&gt;zcyI6Imh0dHA6XC9cLzEyNy4wLjAuMTo4MDgwIiwiZXhwIjoxNTgwNzQ1MjY3LCJpYXQiOjE1ODA3NDE2NjcsImp0aSI6ImJkYzVjZTk5LTE2ZTY&lt;br /&gt;tNDM4Yi1hNjllLTU3MTAzN2RhMTg3OCIsInZpZXdzIjpbXX0.L3fEEEhdCVr3qnmyRKBBUaIQ7dk1VjiFaEBW8hUNjfg&lt;/p&gt;&lt;p&gt;Consumer-Key: ejznk505d132ryomnhbx1qmtohurbsbb0kijajsk&lt;br /&gt;cache-control: no-cache&lt;/p&gt;&lt;p&gt;Maximum time to live of the token is specified over props value consents.max_time_to_live. In case isn&#39;t defined default value is 3600 seconds.&lt;/p&gt;&lt;p&gt;Example of POST JSON:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#x6d;&amp;#97;&amp;#105;l&amp;#x74;o&amp;#58;&amp;#101;v&amp;#x65;&amp;#x6c;&amp;#x69;&amp;#110;&amp;#101;@&amp;#101;&amp;#120;&amp;#x61;m&amp;#112;&amp;#108;&amp;#101;&amp;#x2e;&amp;#99;o&amp;#109;\&quot;&gt;eve&amp;#108;&amp;#x69;&amp;#x6e;&amp;#x65;@&amp;#x65;xa&amp;#109;&amp;#112;&amp;#108;&amp;#101;.&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;&amp;quot;,&lt;br /&gt;&amp;quot;valid_from&amp;quot;: &amp;quot;2020-02-07T08:43:34Z&amp;quot;,&lt;br /&gt;&amp;quot;time_to_live&amp;quot;: 3600&lt;br /&gt;}&lt;br /&gt;Please note that only optional fields are: consumer_id, valid_from and time_to_live.&lt;br /&gt;In case you omit they the default values are used:&lt;br /&gt;consumer_id &#x3D; consumer of current user&lt;br /&gt;valid_from &#x3D; current time&lt;br /&gt;time_to_live &#x3D; consents.max_time_to_live&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;&lt;p&gt;Example 1:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note that consumer_id is optional field&lt;br /&gt;Example 2:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note if everything&#x3D;false you need to explicitly specify views and entitlements&lt;br /&gt;Example 3:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;}&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostConsentImplicitJsonV310 object that needs to be added.
  - @param bANKID The bank id

@return ConsentJsonV310
*/
func (a *PSD2ApiService) CreateConsentImplicit(ctx context.Context, body PostConsentImplicitJsonV310, bANKID string) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consents/IMPLICIT"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent Request
&lt;p&gt;Client Authentication (mandatory)&lt;/p&gt;&lt;p&gt;It is used when applications request an access token to access their own resources, not on behalf of a user.&lt;/p&gt;&lt;p&gt;The client needs to authenticate themselves for this request.&lt;br /&gt;In case of public client we use client_id and private kew to obtain access token, otherwise we use client_id and client_secret.&lt;br /&gt;The obtained access token is used in the HTTP Bearer auth header of our request.&lt;/p&gt;&lt;p&gt;Example:&lt;br /&gt;Authorization: Bearer eXtneO-THbQtn3zvK_kQtXXfvOZyZFdBCItlPDbR2Bk.dOWqtXCtFX-tqGTVR0YrIjvAolPIVg7GZ-jz83y6nA0&lt;/p&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostConsentRequestJsonV500 object that needs to be added.

@return ConsentRequestResponseJson
*/
func (a *PSD2ApiService) CreateConsentRequest(ctx context.Context, body PostConsentRequestJsonV500) (ConsentRequestResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentRequestResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentRequestResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorInvalidJsonFormat
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Consent (SMS)
&lt;p&gt;This endpoint starts the process of creating a Consent.&lt;/p&gt;&lt;p&gt;The Consent is created in an INITIATED state.&lt;/p&gt;&lt;p&gt;A One Time Password (OTP) (AKA security challenge) is sent Out of Band (OOB) to the User via the transport defined in SCA_METHOD&lt;br /&gt;SCA_METHOD is typically &amp;quot;SMS&amp;quot;,&amp;quot;EMAIL&amp;quot; or &amp;quot;IMPLICIT&amp;quot;. &amp;quot;EMAIL&amp;quot; is used for testing purposes. OBP mapped mode &amp;quot;IMPLICIT&amp;quot; is &amp;quot;EMAIL&amp;quot;.&lt;br /&gt;Other mode, bank can decide it in the connector method &#39;getConsentImplicitSCA&#39;.&lt;/p&gt;&lt;p&gt;When the Consent is created, OBP (or a backend system) stores the challenge so it can be checked later against the value supplied by the User with the Answer Consent Challenge endpoint.&lt;/p&gt;&lt;p&gt;An OBP Consent allows the holder of the Consent to call one or more endpoints.&lt;/p&gt;&lt;p&gt;Consents must be created and authorisied using SCA (Strong Customer Authentication).&lt;/p&gt;&lt;p&gt;That is, Consents can be created by an authorised User via the OBP REST API but they must be confirmed via an out of band (OOB) mechanism such as a code sent to a mobile phone.&lt;/p&gt;&lt;p&gt;Each Consent has one of the following states: INITIATED, ACCEPTED, REJECTED, REVOKED, RECEIVED, VALID, REVOKEDBYPSU, EXPIRED, TERMINATEDBYTPP, AUTHORISED, AWAITINGAUTHORISATION.&lt;/p&gt;&lt;p&gt;Each Consent is bound to a consumer i.e. you need to identify yourself over request header value Consumer-Key.&lt;br /&gt;For example:&lt;br /&gt;GET /obp/v4.0.0/users/current HTTP/1.1&lt;br /&gt;Host: 127.0.0.1:8080&lt;br /&gt;Consent-JWT: eyJhbGciOiJIUzI1NiJ9.eyJlbnRpdGxlbWVudHMiOlt7InJvbGVfbmFtZSI6IkNhbkdldEFueVVzZXIiLCJiYW5rX2lkIjoiIn&lt;br /&gt;1dLCJjcmVhdGVkQnlVc2VySWQiOiJhYjY1MzlhOS1iMTA1LTQ0ODktYTg4My0wYWQ4ZDZjNjE2NTciLCJzdWIiOiIzNDc1MDEzZi03YmY5LTQyNj&lt;br /&gt;EtOWUxYy0xZTdlNWZjZTJlN2UiLCJhdWQiOiI4MTVhMGVmMS00YjZhLTQyMDUtYjExMi1lNDVmZDZmNGQzYWQiLCJuYmYiOjE1ODA3NDE2NjcsIml&lt;br /&gt;zcyI6Imh0dHA6XC9cLzEyNy4wLjAuMTo4MDgwIiwiZXhwIjoxNTgwNzQ1MjY3LCJpYXQiOjE1ODA3NDE2NjcsImp0aSI6ImJkYzVjZTk5LTE2ZTY&lt;br /&gt;tNDM4Yi1hNjllLTU3MTAzN2RhMTg3OCIsInZpZXdzIjpbXX0.L3fEEEhdCVr3qnmyRKBBUaIQ7dk1VjiFaEBW8hUNjfg&lt;/p&gt;&lt;p&gt;Consumer-Key: ejznk505d132ryomnhbx1qmtohurbsbb0kijajsk&lt;br /&gt;cache-control: no-cache&lt;/p&gt;&lt;p&gt;Maximum time to live of the token is specified over props value consents.max_time_to_live. In case isn&#39;t defined default value is 3600 seconds.&lt;/p&gt;&lt;p&gt;Example of POST JSON:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#x6c;&amp;#116;&amp;#111;:&amp;#x65;&amp;#118;e&amp;#x6c;&amp;#x69;n&amp;#101;&amp;#64;&amp;#101;x&amp;#97;&amp;#x6d;p&amp;#x6c;&amp;#x65;.co&amp;#x6d;\&quot;&gt;&amp;#x65;&amp;#118;e&amp;#108;&amp;#x69;&amp;#110;&amp;#101;&amp;#x40;e&amp;#120;&amp;#97;&amp;#x6d;&amp;#x70;l&amp;#101;&amp;#x2e;&amp;#99;&amp;#x6f;m&lt;/a&gt;&amp;quot;,&lt;br /&gt;&amp;quot;valid_from&amp;quot;: &amp;quot;2020-02-07T08:43:34Z&amp;quot;,&lt;br /&gt;&amp;quot;time_to_live&amp;quot;: 3600&lt;br /&gt;}&lt;br /&gt;Please note that only optional fields are: consumer_id, valid_from and time_to_live.&lt;br /&gt;In case you omit they the default values are used:&lt;br /&gt;consumer_id &#x3D; consumer of current user&lt;br /&gt;valid_from &#x3D; current time&lt;br /&gt;time_to_live &#x3D; consents.max_time_to_live&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;&lt;p&gt;Example 1:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#109;ai&amp;#108;&amp;#x74;&amp;#x6f;:&amp;#x65;&amp;#x76;&amp;#101;&amp;#x6c;i&amp;#110;e&amp;#x40;&amp;#101;xa&amp;#109;p&amp;#x6c;&amp;#101;.&amp;#x63;&amp;#111;&amp;#x6d;\&quot;&gt;&amp;#101;veli&amp;#x6e;&amp;#101;&amp;#64;e&amp;#120;a&amp;#109;&amp;#112;&amp;#x6c;&amp;#101;&amp;#46;&amp;#x63;&amp;#x6f;&amp;#x6d;&lt;/a&gt;&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note that consumer_id is optional field&lt;br /&gt;Example 2:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: true,&lt;br /&gt;&amp;quot;views&amp;quot;: [],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [],&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#x74;&amp;#111;&amp;#58;&amp;#x65;v&amp;#x65;&amp;#108;i&amp;#x6e;&amp;#x65;&amp;#64;&amp;#x65;&amp;#x78;&amp;#97;&amp;#109;&amp;#x70;l&amp;#101;&amp;#46;&amp;#x63;&amp;#x6f;&amp;#x6d;\&quot;&gt;&amp;#x65;&amp;#118;&amp;#x65;&amp;#108;i&amp;#x6e;&amp;#x65;&amp;#x40;&amp;#101;xa&amp;#x6d;p&amp;#108;&amp;#101;.c&amp;#111;&amp;#x6d;&lt;/a&gt;&amp;quot;&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Please note if everything&#x3D;false you need to explicitly specify views and entitlements&lt;br /&gt;Example 3:&lt;br /&gt;{&lt;br /&gt;&amp;quot;everything&amp;quot;: false,&lt;br /&gt;&amp;quot;views&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;account_id&amp;quot;: &amp;quot;8ca8a7e4-6d02-40e3-a129-0b2bf89de9f0&amp;quot;,&lt;br /&gt;&amp;quot;view_id&amp;quot;: &amp;quot;owner&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;entitlements&amp;quot;: [&lt;br /&gt;{&lt;br /&gt;&amp;quot;bank_id&amp;quot;: &amp;quot;GENODEM1GLS&amp;quot;,&lt;br /&gt;&amp;quot;role_name&amp;quot;: &amp;quot;CanGetCustomer&amp;quot;&lt;br /&gt;}&lt;br /&gt;],&lt;br /&gt;&amp;quot;consumer_id&amp;quot;: &amp;quot;7uy8a7e4-6d02-40e3-a129-0b2bf89de8uh&amp;quot;,&lt;br /&gt;&amp;quot;email&amp;quot;: &amp;quot;&lt;a href&#x3D;\&quot;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#116;&amp;#x6f;&amp;#x3a;&amp;#x65;&amp;#x76;&amp;#x65;l&amp;#105;&amp;#x6e;&amp;#x65;&amp;#64;&amp;#101;&amp;#x78;&amp;#97;mp&amp;#108;&amp;#x65;.&amp;#99;&amp;#x6f;&amp;#109;\&quot;&gt;&amp;#x65;&amp;#x76;&amp;#x65;&amp;#108;i&amp;#110;&amp;#x65;&amp;#x40;&amp;#101;&amp;#x78;am&amp;#112;l&amp;#x65;&amp;#46;&amp;#x63;&amp;#x6f;&amp;#x6d;&lt;/a&gt;&amp;quot;&lt;br /&gt;}&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body PostConsentPhoneJsonV310 object that needs to be added.
  - @param bANKID The bank id

@return ConsentJsonV310
*/
func (a *PSD2ApiService) CreateConsentSms(ctx context.Context, body PostConsentPhoneJsonV310, bANKID string) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consents/SMS"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (ACCOUNT)
&lt;p&gt;When using ACCOUNT, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestAccount(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/ACCOUNT/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (ACCOUNT_OTP)
&lt;p&gt;When using ACCOUNT, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestAccountOtp(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/ACCOUNT_OTP/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (CARD)
&lt;p&gt;When using CARD, the payee is set in the request body .&lt;/p&gt;&lt;p&gt;Money goes into the Counterparty in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyCardJsonV400 object that needs to be added.

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestCard(ctx context.Context, body TransactionRequestBodyCardJsonV400) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/transaction-request-types/CARD/transaction-requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (COUNTERPARTY)
&lt;p&gt;Special instructions for COUNTERPARTY:&lt;/p&gt;&lt;p&gt;When using a COUNTERPARTY to create a Transaction Request, specificy the counterparty_id in the body of the request.&lt;br /&gt;The routing details of the counterparty will be forwarded for the transfer.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyCounterpartyJSON object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestCounterparty(ctx context.Context, body TransactionRequestBodyCounterpartyJson, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/COUNTERPARTY/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (REFUND)
&lt;p&gt;Either the &lt;code&gt;from&lt;/code&gt; or the &lt;code&gt;to&lt;/code&gt; field must be filled. Those fields refers to the information about the party that will be refunded.&lt;/p&gt;&lt;p&gt;In case the &lt;code&gt;from&lt;/code&gt; object is used, it means that the refund comes from the part that sent you a transaction.&lt;br /&gt;In the &lt;code&gt;from&lt;/code&gt; object, you have two choices :&lt;br /&gt;- Use &lt;code&gt;bank_id&lt;/code&gt; and &lt;code&gt;account_id&lt;/code&gt; fields if the other account is registered on the OBP-API&lt;br /&gt;- Use the &lt;code&gt;counterparty_id&lt;/code&gt; field in case the counterparty account is out of the OBP-API&lt;/p&gt;&lt;p&gt;In case the &lt;code&gt;to&lt;/code&gt; object is used, it means you send a request to a counterparty to ask for a refund on a previous transaction you sent.&lt;br /&gt;(This case is not managed by the OBP-API and require an external adapter)&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyRefundJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestRefund(ctx context.Context, body TransactionRequestBodyRefundJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/REFUND/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (SANDBOX_TAN)
&lt;p&gt;When using SANDBOX_TAN, the payee is set in the request body.&lt;/p&gt;&lt;p&gt;Money goes into the BANK_ID and ACCOUNT_ID specified in the request body.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to SANDBOX_TAN. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;{&lt;br /&gt;&amp;quot;XAF&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:1.0,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.0135503,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.00228226,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1.87975,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.00127784,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.00131092,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.0396,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.00601555,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.110241,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.9074795E-8,&lt;br /&gt;&amp;quot;JPY&amp;quot;:0.185328,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.00163773,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.00641333,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.00152449&lt;br /&gt;},&lt;br /&gt;&amp;quot;HKD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:73.8049,&lt;br /&gt;&amp;quot;HKD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.178137,&lt;br /&gt;&amp;quot;KRW&amp;quot;:143.424,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0903452,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0985443,&lt;br /&gt;&amp;quot;MXN&amp;quot;:2.8067,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.467977,&lt;br /&gt;&amp;quot;INR&amp;quot;:9.09325,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.164242461E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:14.0867,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.127427,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.460862,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.112495&lt;br /&gt;},&lt;br /&gt;&amp;quot;AUD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:438.162,&lt;br /&gt;&amp;quot;HKD&amp;quot;:5.61346,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;KRW&amp;quot;:895.304,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.556152,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.609788,&lt;br /&gt;&amp;quot;MXN&amp;quot;:16.0826,&lt;br /&gt;&amp;quot;AED&amp;quot;:2.88368,&lt;br /&gt;&amp;quot;INR&amp;quot;:50.4238,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.2284055924E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:87.0936,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.785256,&lt;br /&gt;&amp;quot;ILS&amp;quot;:2.83558,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.667969&lt;br /&gt;},&lt;br /&gt;&amp;quot;KRW&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:0.531986,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.00697233,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.00111694,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1.0,&lt;br /&gt;&amp;quot;JOD&amp;quot;:6.30634E-4,&lt;br /&gt;&amp;quot;GBP&amp;quot;:6.97389E-4,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.0183,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.00320019,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.0586469,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.4234725E-8,&lt;br /&gt;&amp;quot;JPY&amp;quot;:0.0985917,&lt;br /&gt;&amp;quot;USD&amp;quot;:8.7125E-4,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.00316552,&lt;br /&gt;&amp;quot;EUR&amp;quot;:8.11008E-4&lt;br /&gt;},&lt;br /&gt;&amp;quot;JOD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:782.572,&lt;br /&gt;&amp;quot;HKD&amp;quot;:11.0687,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.63992,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1585.68,&lt;br /&gt;&amp;quot;JOD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;GBP&amp;quot;:1.06757,&lt;br /&gt;&amp;quot;MXN&amp;quot;:30.8336,&lt;br /&gt;&amp;quot;AED&amp;quot;:5.18231,&lt;br /&gt;&amp;quot;INR&amp;quot;:90.1236,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.3803244006E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:156.304,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.41112,&lt;br /&gt;&amp;quot;ILS&amp;quot;:5.02018,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.237707&lt;br /&gt;},&lt;br /&gt;&amp;quot;GBP&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:762.826,&lt;br /&gt;&amp;quot;HKD&amp;quot;:10.1468,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.63992,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1433.92,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.936707,&lt;br /&gt;&amp;quot;GBP&amp;quot;:1.0,&lt;br /&gt;&amp;quot;MXN&amp;quot;:29.242,&lt;br /&gt;&amp;quot;AED&amp;quot;:4.58882,&lt;br /&gt;&amp;quot;INR&amp;quot;:84.095,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.2756409956E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:141.373,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.2493,&lt;br /&gt;&amp;quot;ILS&amp;quot;:4.7002,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.16278&lt;br /&gt;},&lt;br /&gt;&amp;quot;MXN&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:25.189,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.3562,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0621,&lt;br /&gt;&amp;quot;KRW&amp;quot;:54.4512,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0324,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0341,&lt;br /&gt;&amp;quot;MXN&amp;quot;:1.0,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.1688,&lt;br /&gt;&amp;quot;INR&amp;quot;:3.3513,&lt;br /&gt;&amp;quot;XBT&amp;quot;:8.1112586E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:4.8687,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.0459,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.1541,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.0384&lt;br /&gt;},&lt;br /&gt;&amp;quot;AED&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:166.236,&lt;br /&gt;&amp;quot;HKD&amp;quot;:2.13685,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.346779,&lt;br /&gt;&amp;quot;KRW&amp;quot;:312.482,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.1930565,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.217921,&lt;br /&gt;&amp;quot;MXN&amp;quot;:5.9217,&lt;br /&gt;&amp;quot;AED&amp;quot;:1.0,&lt;br /&gt;&amp;quot;INR&amp;quot;:18.3255,&lt;br /&gt;&amp;quot;XBT&amp;quot;:4.603349217E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:30.8081,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.27225,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.968033,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.253425&lt;br /&gt;},&lt;br /&gt;&amp;quot;INR&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:9.07101,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.109972,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0198319,&lt;br /&gt;&amp;quot;KRW&amp;quot;:17.0512,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.0110959,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0118913,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.2983,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.0545671,&lt;br /&gt;&amp;quot;INR&amp;quot;:1.0,&lt;br /&gt;&amp;quot;XBT&amp;quot;:2.2689396E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:1.68111,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.0148559,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.0556764,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.0138287&lt;br /&gt;},&lt;br /&gt;&amp;quot;XBT&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:3.4353824E7,&lt;br /&gt;&amp;quot;HKD&amp;quot;:460448.9,&lt;br /&gt;&amp;quot;AUD&amp;quot;:81168.603,&lt;br /&gt;&amp;quot;KRW&amp;quot;:7.0131575E7,&lt;br /&gt;&amp;quot;JOD&amp;quot;:41960.111,&lt;br /&gt;&amp;quot;GBP&amp;quot;:44188.118,&lt;br /&gt;&amp;quot;MXN&amp;quot;:1230503.3,&lt;br /&gt;&amp;quot;AED&amp;quot;:217414.47,&lt;br /&gt;&amp;quot;INR&amp;quot;:4407607.74,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.0,&lt;br /&gt;&amp;quot;JPY&amp;quot;:6805170.8,&lt;br /&gt;&amp;quot;USD&amp;quot;:59245.918,&lt;br /&gt;&amp;quot;ILS&amp;quot;:182981.21,&lt;br /&gt;&amp;quot;EUR&amp;quot;:52436.431&lt;br /&gt;},&lt;br /&gt;&amp;quot;JPY&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:5.39585,&lt;br /&gt;&amp;quot;HKD&amp;quot;:0.0709891,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.0114819,&lt;br /&gt;&amp;quot;KRW&amp;quot;:10.1428,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.00639777,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.0070735,&lt;br /&gt;&amp;quot;MXN&amp;quot;:0.2053,&lt;br /&gt;&amp;quot;AED&amp;quot;:0.032459,&lt;br /&gt;&amp;quot;INR&amp;quot;:0.594846,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.47171931E-7,&lt;br /&gt;&amp;quot;JPY&amp;quot;:1.0,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.00883695,&lt;br /&gt;&amp;quot;ILS&amp;quot;:0.0320926,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.00822592&lt;br /&gt;},&lt;br /&gt;&amp;quot;USD&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:610.601,&lt;br /&gt;&amp;quot;HKD&amp;quot;:7.84766,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.27347,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1147.78,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.708659,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.800446,&lt;br /&gt;&amp;quot;MXN&amp;quot;:21.748,&lt;br /&gt;&amp;quot;AED&amp;quot;:3.6731,&lt;br /&gt;&amp;quot;INR&amp;quot;:67.3135,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.69154E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:113.161,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.0,&lt;br /&gt;&amp;quot;ILS&amp;quot;:3.55495,&lt;br /&gt;&amp;quot;EUR&amp;quot;:0.930886&lt;br /&gt;},&lt;br /&gt;&amp;quot;ILS&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:155.925,&lt;br /&gt;&amp;quot;HKD&amp;quot;:2.16985,&lt;br /&gt;&amp;quot;AUD&amp;quot;:0.352661,&lt;br /&gt;&amp;quot;KRW&amp;quot;:315.903,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.199196,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.212763,&lt;br /&gt;&amp;quot;MXN&amp;quot;:6.4871,&lt;br /&gt;&amp;quot;AED&amp;quot;:1.03302,&lt;br /&gt;&amp;quot;INR&amp;quot;:17.9609,&lt;br /&gt;&amp;quot;XBT&amp;quot;:5.452272147E-6,&lt;br /&gt;&amp;quot;JPY&amp;quot;:31.1599,&lt;br /&gt;&amp;quot;USD&amp;quot;:0.281298,&lt;br /&gt;&amp;quot;ILS&amp;quot;:1.0,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.19318&lt;br /&gt;},&lt;br /&gt;&amp;quot;EUR&amp;quot;:{&lt;br /&gt;&amp;quot;XAF&amp;quot;:655.957,&lt;br /&gt;&amp;quot;HKD&amp;quot;:8.88926,&lt;br /&gt;&amp;quot;AUD&amp;quot;:1.49707,&lt;br /&gt;&amp;quot;KRW&amp;quot;:1233.03,&lt;br /&gt;&amp;quot;JOD&amp;quot;:0.838098,&lt;br /&gt;&amp;quot;GBP&amp;quot;:0.860011,&lt;br /&gt;&amp;quot;MXN&amp;quot;:26.0359,&lt;br /&gt;&amp;quot;AED&amp;quot;:3.94594,&lt;br /&gt;&amp;quot;INR&amp;quot;:72.3136,&lt;br /&gt;&amp;quot;XBT&amp;quot;:1.9087905636E-5,&lt;br /&gt;&amp;quot;JPY&amp;quot;:121.567,&lt;br /&gt;&amp;quot;USD&amp;quot;:1.07428,&lt;br /&gt;&amp;quot;ILS&amp;quot;:4.20494,&lt;br /&gt;&amp;quot;EUR&amp;quot;:1.0&lt;br /&gt;}&lt;br /&gt;}&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodyJsonV200 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *PSD2ApiService) CreateTransactionRequestSandboxTan(ctx context.Context, body TransactionRequestBodyJsonV200, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SANDBOX_TAN/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (SEPA)
&lt;p&gt;Special instructions for SEPA:&lt;/p&gt;&lt;p&gt;When using a SEPA Transaction Request, you specify the IBAN of a Counterparty in the body of the request.&lt;br /&gt;The routing details (IBAN) of the counterparty will be forwarded to the core banking system for the transfer.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodySEPAJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestSepa(ctx context.Context, body TransactionRequestBodySepaJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SEPA/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Create Transaction Request (SIMPLE)
&lt;p&gt;Special instructions for SIMPLE:&lt;/p&gt;&lt;p&gt;You can transfer money to the Bank Account Number or IBAN directly.&lt;/p&gt;&lt;p&gt;Initiate a Payment via creating a Transaction Request.&lt;/p&gt;&lt;p&gt;In OBP, a &lt;code&gt;transaction request&lt;/code&gt; may or may not result in a &lt;code&gt;transaction&lt;/code&gt;. However, a &lt;code&gt;transaction&lt;/code&gt; only has one possible state: completed.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; can have one of several states: INITIATED, NEXT_CHALLENGE_PENDING etc.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transactions&lt;/code&gt; are modeled on items in a bank statement that represent the movement of money.&lt;/p&gt;&lt;p&gt;&lt;code&gt;Transaction Requests&lt;/code&gt; are requests to move money which may or may not succeed and thus result in a &lt;code&gt;Transaction&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;Transaction Request&lt;/code&gt; might create a security challenge that needs to be answered before the &lt;code&gt;Transaction Request&lt;/code&gt; proceeds.&lt;br /&gt;In case 1 person needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; COMPLETED&lt;br /&gt;In case n persons needs to answer security challenge we have next flow of state of an &lt;code&gt;transaction request&lt;/code&gt;:&lt;br /&gt;INITIATED &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; ... &#x3D;&amp;gt; NEXT_CHALLENGE_PENDING &#x3D;&amp;gt; COMPLETED&lt;/p&gt;&lt;p&gt;The security challenge is bound to a user i.e. in case of right answer and the user is different than expected one the challenge will fail.&lt;/p&gt;&lt;p&gt;Rule for calculating number of security challenges:&lt;br /&gt;If product Account attribute REQUIRED_CHALLENGE_ANSWERS&#x3D;N then create N challenges&lt;br /&gt;(one for every user that has a View where permission &amp;quot;can_add_transaction_request_to_any_account&amp;quot;&#x3D;true)&lt;br /&gt;In case REQUIRED_CHALLENGE_ANSWERS is not defined as an account attribute default value is 1.&lt;/p&gt;&lt;p&gt;Transaction Requests contain charge information giving the client the opportunity to proceed or not (as long as the challenge level is appropriate).&lt;/p&gt;&lt;p&gt;Transaction Requests can have one of several Transaction Request Types which expect different bodies. The escaped body is returned in the details key of the GET response.&lt;br /&gt;This provides some commonality and one URL for many different payment or transfer types with enough flexibility to validate them differently.&lt;/p&gt;&lt;p&gt;The payer is set in the URL. Money comes out of the BANK_ID and ACCOUNT_ID specified in the URL.&lt;/p&gt;&lt;p&gt;In sandbox mode, TRANSACTION_REQUEST_TYPE is commonly set to ACCOUNT. See getTransactionRequestTypesSupportedByBank for all supported types.&lt;/p&gt;&lt;p&gt;In sandbox mode, if the amount is less than 1000 EUR (any currency, unless it is set differently on this server), the transaction request will create a transaction without a challenge, else the Transaction Request will be set to INITIALISED and a challenge will need to be answered.&lt;/p&gt;&lt;p&gt;If a challenge is created you must answer it using Answer Transaction Request Challenge before the Transaction is created.&lt;/p&gt;&lt;p&gt;You can transfer between different currency accounts. (new in 2.0.0). The currency in body must match the sending account.&lt;/p&gt;&lt;p&gt;The following static FX rates are available in sandbox mode:&lt;/p&gt;&lt;p&gt;&lt;a href&#x3D;\&quot;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate\&quot;&gt;https://test-explorer.openbankproject.com/more?version&#x3D;OBPv4.0.0&amp;amp;list-all-banks&#x3D;false&amp;amp;core&#x3D;&amp;amp;psd2&#x3D;&amp;amp;obwg&#x3D;#OBPv2_2_0-getCurrentFxRate&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Transaction Requests satisfy PSD2 requirements thus:&lt;/p&gt;&lt;p&gt;1) A transaction can be initiated by a third party application.&lt;/p&gt;&lt;p&gt;2) The customer is informed of the charge that will incurred.&lt;/p&gt;&lt;p&gt;3) The call supports delegated authentication (OAuth)&lt;/p&gt;&lt;p&gt;See &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/Hello-OBP-DirectLogin-Python/blob/master/hello_payments.py\&quot;&gt;this python code&lt;/a&gt; for a complete example of this flow.&lt;/p&gt;&lt;p&gt;There is further documentation &lt;a href&#x3D;\&quot;https://github.com/OpenBankProject/OBP-API/wiki/Transaction-Requests\&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body TransactionRequestBodySimpleJsonV400 object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson400
*/
func (a *PSD2ApiService) CreateTransactionRequestSimple(ctx context.Context, body TransactionRequestBodySimpleJsonV400, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types/SIMPLE/transaction-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TransactionRequestWithChargeJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Accounts Held
&lt;p&gt;Get Accounts held by the current User if even the User has not been assigned the owner View yet.&lt;/p&gt;&lt;p&gt;Can be used to onboard the account to the API - since all other account and transaction endpoints require views to be assigned.&lt;/p&gt;&lt;p&gt;optional request parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;account_type_filter: one or many accountType value, split by comma&lt;/li&gt;&lt;li&gt;account_type_filter_operation: the filter type of account_type_filter, value must be INCLUDE or EXCLUDE&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;whole url example:&lt;br /&gt;/banks/BANK_ID/accounts-held?account_type_filter&#x3D;330,CURRENT+PLUS&amp;amp;account_type_filter_operation&#x3D;INCLUDE&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return CoreAccountsHeldJsonV300
*/
func (a *PSD2ApiService) GetAccountsHeld(ctx context.Context, bANKID string) (CoreAccountsHeldJsonV300, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CoreAccountsHeldJsonV300
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts-held"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CoreAccountsHeldJsonV300
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Bank
&lt;p&gt;Get the bank specified by BANK_ID&lt;br /&gt;Returns information about a single bank specified by BANK_ID including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Bank code and full name of bank&lt;/li&gt;&lt;li&gt;Logo URL&lt;/li&gt;&lt;li&gt;Website&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return BankJson500
*/
func (a *PSD2ApiService) GetBank(ctx context.Context, bANKID string) (BankJson500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue BankJson500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v BankJson500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUnknownError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Account Balances
&lt;p&gt;Get the Balances for one Account of the current User at one bank.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return AccountBalanceJsonV400
*/
func (a *PSD2ApiService) GetBankAccountBalances(ctx context.Context, aCCOUNTID string, bANKID string) (AccountBalanceJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AccountBalanceJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/balances"
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AccountBalanceJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Accounts Balances
&lt;p&gt;Get the Balances for the Accounts of the current User at one bank.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return AccountsBalancesJsonV400
*/
func (a *PSD2ApiService) GetBankAccountsBalances(ctx context.Context, bANKID string) (AccountsBalancesJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AccountsBalancesJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/balances"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AccountsBalancesJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Banks
&lt;p&gt;Get banks on this API instance&lt;br /&gt;Returns a list of banks supported on this server:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ID used as parameter in URLs&lt;/li&gt;&lt;li&gt;Short and full name of bank&lt;/li&gt;&lt;li&gt;Logo URL&lt;/li&gt;&lt;li&gt;Website&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return BanksJson400
*/
func (a *PSD2ApiService) GetBanks(ctx context.Context) (BanksJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue BanksJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v BanksJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUnknownError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Consent By Consent Id
&lt;p&gt;This endpoint gets the Consent By consent id.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cONSENTID the consent id

@return ConsentJsonV500
*/
func (a *PSD2ApiService) GetConsentByConsentId(ctx context.Context, cONSENTID string) (ConsentJsonV500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consents/{CONSENT_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CONSENT_ID"+"}", fmt.Sprintf("%v", cONSENTID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentJsonV500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Consent By Consent Request Id
&lt;p&gt;This endpoint gets the Consent By consent request id.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentJsonV500
*/
func (a *PSD2ApiService) GetConsentByConsentRequestId(ctx context.Context) (ConsentJsonV500, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV500
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests/CONSENT_REQUEST_ID/consents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentJsonV500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Consents Info
&lt;p&gt;This endpoint gets the Consents that the current User created.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return ConsentInfosJsonV400
*/
func (a *PSD2ApiService) GetConsentInfos(ctx context.Context, bANKID string) (ConsentInfosJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentInfosJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consent-infos"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentInfosJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Consent Request
&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentRequestResponseJson
*/
func (a *PSD2ApiService) GetConsentRequest(ctx context.Context) (ConsentRequestResponseJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentRequestResponseJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/consumer/consent-requests/CONSENT_REQUEST_ID"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentRequestResponseJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorInvalidJsonFormat
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Consents
&lt;p&gt;This endpoint gets the Consents that the current User created.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return ConsentsJsonV400
*/
func (a *PSD2ApiService) GetConsents(ctx context.Context, bANKID string) (ConsentsJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentsJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consents"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentsJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Account by Id (Core)
&lt;p&gt;Information returned about the account specified by ACCOUNT_ID:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Number - The human readable account number given by the bank that identifies the account.&lt;/li&gt;&lt;li&gt;Label - A label given by the owner of the account&lt;/li&gt;&lt;li&gt;Owners - Users that own this account&lt;/li&gt;&lt;li&gt;Type - The type of account&lt;/li&gt;&lt;li&gt;Balance - Currency and Value&lt;/li&gt;&lt;li&gt;Account Routings - A list that might include IBAN or national account identifiers&lt;/li&gt;&lt;li&gt;Account Rules - A list that might include Overdraft and other bank specific rules&lt;/li&gt;&lt;li&gt;Tags - A list of Tags assigned to this account&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This call returns the owner view and requires access to that view.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return ModeratedCoreAccountJsonV400
*/
func (a *PSD2ApiService) GetCoreAccountById(ctx context.Context, aCCOUNTID string, bANKID string) (ModeratedCoreAccountJsonV400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ModeratedCoreAccountJsonV400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/my/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/account"
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ModeratedCoreAccountJsonV400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Transactions for Account (Core)
&lt;p&gt;Returns transactions list (Core info) of the account specified by ACCOUNT_ID.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;&lt;p&gt;Possible custom url parameters for pagination:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;limit&#x3D;NUMBER &#x3D;&#x3D;&amp;gt; default value: 500&lt;/li&gt;&lt;li&gt;offset&#x3D;NUMBER &#x3D;&#x3D;&amp;gt; default value: 0&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;eg1:?limit&#x3D;100&amp;amp;offset&#x3D;0&lt;/p&gt;&lt;ul&gt;&lt;li&gt;sort_direction&#x3D;ASC/DESC &#x3D;&#x3D;&amp;gt; default value: DESC.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;eg2:?limit&#x3D;100&amp;amp;offset&#x3D;0&amp;amp;sort_direction&#x3D;ASC&lt;/p&gt;&lt;ul&gt;&lt;li&gt;from_date&#x3D;DATE &#x3D;&amp;gt; example value: 1970-01-01T00:00:00.000Z. NOTE! The default value is one year ago (1970-01-01T00:00:00.000Z).&lt;/li&gt;&lt;li&gt;to_date&#x3D;DATE &#x3D;&amp;gt; example value: 2024-02-05T14:15:55.255Z. NOTE! The default value is now (2024-02-05T14:15:55.255Z).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Date format parameter: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;(1100-01-01T01:01:01.000Z) &#x3D;&#x3D;&amp;gt; time zone is UTC.&lt;/p&gt;&lt;p&gt;eg3:?sort_direction&#x3D;ASC&amp;amp;limit&#x3D;100&amp;amp;offset&#x3D;0&amp;amp;from_date&#x3D;1100-01-01T01:01:01.000Z&amp;amp;to_date&#x3D;1100-01-01T01:01:01.000Z&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return CoreTransactionsJsonV300
*/
func (a *PSD2ApiService) GetCoreTransactionsForBankAccount(ctx context.Context, aCCOUNTID string, bANKID string) (CoreTransactionsJsonV300, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CoreTransactionsJsonV300
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/my/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CoreTransactionsJsonV300
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorFilterSortDirectionError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Counterparties for any account (Explicit)
&lt;p&gt;Get the Counterparties (Explicit) for any account .&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return CounterpartiesJson400
*/
func (a *PSD2ApiService) GetCounterpartiesForAnyAccount(ctx context.Context, vIEWID string, aCCOUNTID string, bANKID string) (CounterpartiesJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CounterpartiesJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/management/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/counterparties"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CounterpartiesJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Counterparties (Explicit)
&lt;p&gt;Get the Counterparties (Explicit) for the account / view.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return CounterpartiesJson400
*/
func (a *PSD2ApiService) GetExplictCounterpartiesForAccount(ctx context.Context, vIEWID string, aCCOUNTID string, bANKID string) (CounterpartiesJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CounterpartiesJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/counterparties"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CounterpartiesJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Counterparty by Id (Explicit)
&lt;p&gt;Information returned about the Counterparty specified by COUNTERPARTY_ID:&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cOUNTERPARTYID the counterparty id
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return CounterpartyWithMetadataJson400
*/
func (a *PSD2ApiService) GetExplictCounterpartyById(ctx context.Context, cOUNTERPARTYID string, vIEWID string, aCCOUNTID string, bANKID string) (CounterpartyWithMetadataJson400, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CounterpartyWithMetadataJson400
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/counterparties/{COUNTERPARTY_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"COUNTERPARTY_ID"+"}", fmt.Sprintf("%v", cOUNTERPARTYID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CounterpartyWithMetadataJson400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Accounts at Bank (IDs only)
&lt;p&gt;Returns only the list of accounts ids at BANK_ID that the user has access to.&lt;/p&gt;&lt;p&gt;Each account must have at least one private View.&lt;/p&gt;&lt;p&gt;For each account the API returns its account ID.&lt;/p&gt;&lt;p&gt;If you want to see more information on the Views, use the Account Detail call.&lt;/p&gt;&lt;p&gt;optional request parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;account_type_filter: one or many accountType value, split by comma&lt;/li&gt;&lt;li&gt;account_type_filter_operation: the filter type of account_type_filter, value must be INCLUDE or EXCLUDE&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;whole url example:&lt;br /&gt;/banks/BANK_ID/accounts/account_ids/private?account_type_filter&#x3D;330,CURRENT+PLUS&amp;amp;account_type_filter_operation&#x3D;INCLUDE&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return AccountsIdsJsonV300
*/
func (a *PSD2ApiService) GetPrivateAccountIdsbyBankId(ctx context.Context, bANKID string) (AccountsIdsJsonV300, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AccountsIdsJsonV300
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/account_ids/private"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AccountsIdsJsonV300
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get JSON Web Key (JWK)
&lt;p&gt;Get the server&#39;s public JSON Web Key (JWK) set and certificate chain.&lt;br /&gt;It is required by client applications to validate ID tokens, self-contained access tokens and other issued objects.&lt;/p&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return SeverJwk
*/
func (a *PSD2ApiService) GetServerJWK(ctx context.Context) (SeverJwk, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SeverJwk
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/certs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SeverJwk
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUnknownError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Settlement accounts at Bank
&lt;p&gt;Get settlement accounts on this API instance&lt;br /&gt;Returns a list of settlement accounts at this Bank&lt;/p&gt;&lt;p&gt;Note: a settlement account is considered as a bank account.&lt;br /&gt;So you can update it and add account attributes to it using the regular account endpoints&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return SettlementAccountsJson
*/
func (a *PSD2ApiService) GetSettlementAccounts(ctx context.Context, bANKID string) (SettlementAccountsJson, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SettlementAccountsJson
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/settlement-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SettlementAccountsJson
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Transaction Request.
&lt;p&gt;Returns transaction request for transaction specified by TRANSACTION_REQUEST_ID and for account specified by ACCOUNT_ID at bank specified by BANK_ID.&lt;/p&gt;&lt;p&gt;The VIEW_ID specified must be &#39;owner&#39; and the user must have access to this view.&lt;/p&gt;&lt;p&gt;Version 2.0.0 now returns charge information.&lt;/p&gt;&lt;p&gt;Transaction Requests serve to initiate transactions that may or may not proceed. They contain information including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Transaction Request Id&lt;/li&gt;&lt;li&gt;Type&lt;/li&gt;&lt;li&gt;Status (INITIATED, COMPLETED)&lt;/li&gt;&lt;li&gt;Challenge (in order to confirm the request)&lt;/li&gt;&lt;li&gt;From Bank / Account&lt;/li&gt;&lt;li&gt;Details including Currency, Value, Description and other initiation information specific to each type. (Could potentialy include a list of future transactions.)&lt;/li&gt;&lt;li&gt;Related Transactions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;PSD2 Context: PSD2 requires transparency of charges to the customer.&lt;br /&gt;This endpoint provides the charge that would be applied if the Transaction Request proceeds - and a record of that charge there after.&lt;br /&gt;The customer can proceed with the Transaction by answering the security challenge.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param tRANSACTIONREQUESTID The transaction request id
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestWithChargeJson210
*/
func (a *PSD2ApiService) GetTransactionRequest(ctx context.Context, tRANSACTIONREQUESTID string, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestWithChargeJson210, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestWithChargeJson210
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-requests/{TRANSACTION_REQUEST_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TRANSACTION_REQUEST_ID"+"}", fmt.Sprintf("%v", tRANSACTIONREQUESTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestWithChargeJson210
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Transaction Request Types for Account
&lt;p&gt;Returns the Transaction Request Types that the account specified by ACCOUNT_ID and view specified by VIEW_ID has access to.&lt;/p&gt;&lt;p&gt;These are the ways this API Server can create a Transaction via a Transaction Request&lt;br /&gt;(as opposed to Transaction Types which include external types too e.g. for Transactions created by core banking etc.)&lt;/p&gt;&lt;p&gt;A Transaction Request Type internally determines:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the required Transaction Request &#39;body&#39; i.e. fields that define the &#39;what&#39; and &#39;to&#39; of a Transaction Request,&lt;/li&gt;&lt;li&gt;the type of security challenge that may be be raised before the Transaction Request proceeds, and&lt;/li&gt;&lt;li&gt;the threshold of that challenge.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For instance in a &#39;SANDBOX_TAN&#39; Transaction Request, for amounts over 1000 currency units, the user must supply a positive integer to complete the Transaction Request and create a Transaction.&lt;/p&gt;&lt;p&gt;This approach aims to provide only one endpoint for initiating transactions, and one that handles challenges, whilst still allowing flexibility with the payload and internal logic.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body EmptyClassJson object that needs to be added.
  - @param vIEWID The view id
  - @param aCCOUNTID The account id
  - @param bANKID The bank id

@return TransactionRequestTypesJsonV140
*/
func (a *PSD2ApiService) GetTransactionRequestTypes(ctx context.Context, body EmptyClassJson, vIEWID string, aCCOUNTID string, bANKID string) (TransactionRequestTypesJsonV140, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionRequestTypesJsonV140
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/{ACCOUNT_ID}/{VIEW_ID}/transaction-request-types"
	localVarPath = strings.Replace(localVarPath, "{"+"VIEW_ID"+"}", fmt.Sprintf("%v", vIEWID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ACCOUNT_ID"+"}", fmt.Sprintf("%v", aCCOUNTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionRequestTypesJsonV140
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Transaction Types at Bank
&lt;p&gt;Get Transaction Types for the bank specified by BANK_ID:&lt;/p&gt;&lt;p&gt;Lists the possible Transaction Types available at the bank (as opposed to Transaction Request Types which are the possible ways Transactions can be created by this API Server).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;id : Unique transaction type id across the API instance. SHOULD be a UUID. MUST be unique.&lt;/li&gt;&lt;li&gt;bank_id : The bank that supports this TransactionType&lt;/li&gt;&lt;li&gt;short_code : A short code (SHOULD have no-spaces) which MUST be unique across the bank. May be stored with Transactions to link here&lt;/li&gt;&lt;li&gt;summary : A succinct summary&lt;/li&gt;&lt;li&gt;description : A longer description&lt;/li&gt;&lt;li&gt;charge : The charge to the customer for each one of these&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Authentication is Optional&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body EmptyClassJson object that needs to be added.
  - @param bANKID The bank id

@return TransactionTypesJsonV200
*/
func (a *PSD2ApiService) GetTransactionTypes(ctx context.Context, body EmptyClassJson, bANKID string) (TransactionTypesJsonV200, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TransactionTypesJsonV200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/transaction-types"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TransactionTypesJsonV200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorBankNotFound
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Provide client&#39;s certificate info of a current call
&lt;p&gt;Provide client&#39;s certificate info of a current call specified by PSD2-CERT value at Request Header&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return CertificateInfoJsonV510
*/
func (a *PSD2ApiService) MtlsClientCertificateInfo(ctx context.Context) (CertificateInfoJsonV510, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CertificateInfoJsonV510
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/my/mtls/certificate/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CertificateInfoJsonV510
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Get Accounts at Bank (Minimal)
&lt;p&gt;Returns the minimal list of private accounts at BANK_ID that the user has access to.&lt;br /&gt;For each account, the API returns the ID, routing addresses and the views available to the current user.&lt;/p&gt;&lt;p&gt;If you want to see more information on the Views, use the Account Detail call.&lt;/p&gt;&lt;p&gt;optional request parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;account_type_filter: one or many accountType value, split by comma&lt;/li&gt;&lt;li&gt;account_type_filter_operation: the filter type of account_type_filter, value must be INCLUDE or EXCLUDE&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;whole url example:&lt;br /&gt;/banks/BANK_ID/accounts/private?account_type_filter&#x3D;330,CURRENT+PLUS&amp;amp;account_type_filter_operation&#x3D;INCLUDE&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bANKID The bank id

@return CoreAccountsJsonV300
*/
func (a *PSD2ApiService) PrivateAccountsAtOneBank(ctx context.Context, bANKID string) (CoreAccountsJsonV300, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CoreAccountsJsonV300
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/accounts/private"
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CoreAccountsJsonV300
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Revoke Consent
&lt;p&gt;Revoke Consent for current user specified by CONSENT_ID&lt;/p&gt;&lt;p&gt;There are a few reasons you might need to revoke an applications access to a users account:&lt;br /&gt;- The user explicitly wishes to revoke the applications access&lt;br /&gt;- You as the service provider have determined an application is compromised or malicious, and want to disable it&lt;br /&gt;- etc.&lt;/p&gt;&lt;p&gt;Please note that this endpoint only supports the case:: &amp;quot;The user explicitly wishes to revoke the applications access&amp;quot;&lt;/p&gt;&lt;p&gt;OBP as a resource server stores access tokens in a database, then it is relatively easy to revoke some token that belongs to a particular user.&lt;br /&gt;The status of the token is changed to &amp;quot;REVOKED&amp;quot; so the next time the revoked client makes a request, their token will fail to validate.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cONSENTID the consent id
  - @param bANKID The bank id

@return ConsentJsonV310
*/
func (a *PSD2ApiService) RevokeConsent(ctx context.Context, cONSENTID string, bANKID string) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/my/consents/{CONSENT_ID}/revoke"
	localVarPath = strings.Replace(localVarPath, "{"+"CONSENT_ID"+"}", fmt.Sprintf("%v", cONSENTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Revoke Consent at Bank
&lt;p&gt;Revoke Consent specified by CONSENT_ID&lt;/p&gt;&lt;p&gt;There are a few reasons you might need to revoke an applications access to a users account:&lt;br /&gt;- The user explicitly wishes to revoke the applications access&lt;br /&gt;- You as the service provider have determined an application is compromised or malicious, and want to disable it&lt;br /&gt;- etc.&lt;/p&gt;&lt;p&gt;OBP as a resource server stores access tokens in a database, then it is relatively easy to revoke some token that belongs to a particular user.&lt;br /&gt;The status of the token is changed to &amp;quot;REVOKED&amp;quot; so the next time the revoked client makes a request, their token will fail to validate.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param cONSENTID the consent id
  - @param bANKID The bank id

@return ConsentJsonV310
*/
func (a *PSD2ApiService) RevokeConsentAtBank(ctx context.Context, cONSENTID string, bANKID string) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/banks/{BANK_ID}/consents/{CONSENT_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CONSENT_ID"+"}", fmt.Sprintf("%v", cONSENTID), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"BANK_ID"+"}", fmt.Sprintf("%v", bANKID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 204 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PSD2ApiService Revoke Consent used in the Current Call
&lt;p&gt;Revoke Consent specified by Consent-Id at Request Header&lt;/p&gt;&lt;p&gt;There are a few reasons you might need to revoke an applications access to a users account:&lt;br /&gt;- The user explicitly wishes to revoke the applications access&lt;br /&gt;- You as the service provider have determined an application is compromised or malicious, and want to disable it&lt;br /&gt;- etc.&lt;/p&gt;&lt;p&gt;OBP as a resource server stores access tokens in a database, then it is relatively easy to revoke some token that belongs to a particular user.&lt;br /&gt;The status of the token is changed to &amp;quot;REVOKED&amp;quot; so the next time the revoked client makes a request, their token will fail to validate.&lt;/p&gt;&lt;p&gt;Authentication is Mandatory&lt;/p&gt;
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ConsentJsonV310
*/
func (a *PSD2ApiService) SelfRevokeConsent(ctx context.Context) (ConsentJsonV310, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ConsentJsonV310
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/obp/v5.1.0/my/consent/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 204 {
			var v ConsentJsonV310
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorUserNotLoggedIn
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
